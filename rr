data "azurerm_client_config" "current" {}

# Fetch SKUs filtered by location
data "azapi_resource_action" "skus" {
  type                   = "Microsoft.Compute@2021-07-01"
  resource_id            = "/subscriptions/${data.azurerm_client_config.current.subscription_id}/providers/Microsoft.Compute"
  action                 = "skus?api-version=2021-07-01&filter=location%20eq%20'${var.location}'"
  method                 = "GET"
  response_export_values = ["*"]
}

# Variable for preferred zones
variable "preferred_zones" {
  type    = list(string)
  default = ["1", "2", "3"]
}

# Process the SKUs
locals {
  raw_vm_skus = [
    for sku in jsondecode(data.azapi_resource_action.skus.output).value : {
      name          = sku.name
      resourceType  = sku.resourceType
      tier          = sku.tier
      size          = sku.size
      family        = sku.family
      locations     = [for info in sku.locationInfo : info.location]
      capabilities  = { for capability in sku.capabilities : capability.name => capability.value }
    } if sku.resourceType == "virtualMachines"
  ]

  all_vm_skus = [
    for sku in local.raw_vm_skus : {
      name         = sku.name
      resourceType = sku.resourceType
      tier         = sku.tier
      size         = sku.size
      family       = sku.family
      locations    = sku.locations
      resources = {
        vcpus           = tonumber(sku.capabilities["vCPUs"])
        vcpus_available = tonumber(sku.capabilities["vCPUsAvailable"])
        vcpus_per_core  = tonumber(sku.capabilities["vCPUsPerCore"])
        memory_gb       = tonumber(sku.capabilities["MemoryGB"])
        gpus            = tonumber(lookup(sku.capabilities, "GPUs", "0"))
        max_disk_count  = tonumber(sku.capabilities["MaxDataDiskCount"])
      }
      features = {
        premium_io                    = sku.capabilities["PremiumIO"] == "True"
        memory_preserving_maintenance = sku.capabilities["MemoryPreservingMaintenanceSupported"] == "True"
        low_priority                  = sku.capabilities["LowPriorityCapable"] == "True"
        hibernation                   = lookup(sku.capabilities, "HibernationSupported", "False") == "True"
        encryption_at_host            = sku.capabilities["EncryptionAtHostSupported"] == "True"
        ephemeral_os_disk             = sku.capabilities["EphemeralOSDiskSupported"] == "True"
        capacity_reservation          = sku.capabilities["CapacityReservationSupported"] == "True"
      }
    }
  ]

  matching_vm_skus = [
    for sku in local.all_vm_skus : sku
    if sku.name == var.vm_size && contains(sku.locations, var.location)
  ]

  available_zones = distinct(flatten([
    for sku in local.matching_vm_skus : sku.locations
  ]))

  selected_zone = length([
    for zone in var.preferred_zones : zone
    if contains(local.available_zones, zone)
  ]) > 0 ? [
    for zone in var.preferred_zones : zone
    if contains(local.available_zones, zone)
  ][0] : null

  valid_vm_size = local.selected_zone != null
}

# Validation: fail fast if no matching SKU or zone
vm_size_validation = local.valid_vm_size ? "" : error("ERROR: VM size '${var.vm_size}' is not available in '${var.location}' or no matching zone found!")

output "vm_size_validation_check" {
  value       = local.valid_vm_size
  description = "Testing validation output"
}

output "selected_zone" {
  value       = local.selected_zone
  description = "Zone selected for VM deployment"
}

# Example use in a VM resource (reference zone dynamically)
# resource "azurerm_linux_virtual_machine" "example" {
#   name     = "my-vm"
#   location = var.location
#   zone     = local.selected_zone
#   ...
# }
