AFT Customizations Repository – Refactoring Approach
1. Overview

This document outlines the structured approach to refactoring the AFT (Account Factory for Terraform) Customizations Repository. The goal is to improve modularity, reduce dependencies, enable independent deployments, and standardize state and environment management. The current monolithic structure tightly couples components and increases operational complexity.

This plan defines the phases, tasks, deliverables, and expected outcomes required to transition from the current monolithic design to a scalable, modular, maintainable architecture.

2. Business Value

Refactoring the AFT customizations repository enables:

Independent deployment of components

Reduced blast radius for changes

Faster and safer deployment workflows

Improved maintainability and code organization

Clear environment variable and configuration management

Better alignment with Terraform modular design patterns

A predictable onboarding experience for engineers

3. Current State Summary

AFT customizations are stored in one monolithic repository

Multiple components share a single Terraform state

File, folder, and variable patterns are inconsistent

Environment variable management is unclear and spread across locations

CI/CD pipelines require full-repo builds, causing large deployment scopes

Dependencies between components are not documented or clear

4. Desired Future State

Components are logically separated into individual repositories or distinct Terraform modules

Each component uses its own isolated Terraform state backend

A standardized environment variable and tfvars file structure exists across environments

Module interfaces (inputs/outputs) are well-defined and documented

Dependencies between components are minimized and documented

CI/CD pipelines support component-level deployments

Repository layout and architecture diagrams accurately represent the new structure

5. Refactoring Phases
5.1 Phase 1 – Analysis

Purpose:
Understand the current state of the AFT customizations repository, inventory all components, and document existing dependencies, state usage, environment structures, and risks.

Tasks:

Inventory all components

Create a full list of modules, folders, and logical components

Capture purpose, owner, environments used, and criticality

Map dependencies

Identify module-to-module interactions

Document shared resources and cross-module dependencies

Categorize dependencies as strong, weak, or unnecessary

Review Terraform state usage

Identify shared state files and coupled components

Document backend configuration

Document file & environment structure

Capture folder hierarchy

Document variable files, environment definitions, and templates

Identify how environment variables and secrets are consumed

Identify risks and opportunities

Highlight high-coupling areas

Identify components that are easy wins for early isolation

Expected Outputs:

Component inventory table

Dependency map

Current state backend documentation

Current file/folder structure documentation

Analysis summary including risks, assumptions, and constraints

5.2 Phase 2 – Design

Purpose:
Define the target architecture, module structure, state management strategy, and standardization rules that will guide the refactoring effort.

Tasks:

Design new module/repository structure

Group components into logical modules

Define whether modules live in a monorepo or multiple repos

Create a standardized folder structure

Define the state management strategy

Create one state backend per component/module

Define remote backend naming conventions

Define strategy for cross-module access (data sources, remote state, or parameter passing)

Standardize environment variable & tfvars structure

Design a hierarchical folder structure (e.g., env/dev.tfvars, env/prod.tfvars)

Define naming conventions and templates

Identify global vs per-module variables

Define module contracts (interfaces)

Document required inputs, optional inputs, and outputs

Standardize naming conventions for variables and outputs

Create the refactoring proposal & prioritization

Prioritize components by complexity: low / medium / high

Identify migration risks

Recommend deployment/migration order

Expected Outputs:

Refactoring proposal document

Target module/repository structure diagram

State management strategy documentation

Standardized environment variable template

Module interface definitions

Prioritized isolation list with complexity and risk

5.3 Phase 3 – Documentation & Runbook

Purpose:
Create operational documentation that describes how to perform the refactoring, deploy new modules, and manage future changes.

Tasks:

Create the Refactoring Runbook

Step-by-step process for isolating each component:

Create new module/repo

Move code and update imports/paths

Create new Terraform backend

Migrate/import state when required

Wire module inputs/outputs

Update CI/CD pipelines

Test in non-prod

Deploy to production

Document deployment procedures

Component-specific deployment guidance

CI/CD pipeline flows and triggers

Environment-specific deployment rules

Define rollback procedures

Terraform state recovery

Module version rollback

Environment variable rollback

Create diagrams

“Current vs future” architecture diagrams

Component dependency diagrams

CI/CD workflow diagrams

Update onboarding documentation

New developer guidelines

How to add a new module

How to use the standardized env structure

Expected Outputs:

Refactoring Runbook

Deployment Procedures

Rollback Procedures

Architecture diagrams

Updated onboarding documentation

6. Definition of Done

The refactoring initiative is considered complete when:

Analysis document is finalized and reviewed

Refactoring proposal is approved by stakeholders

Environment variable structure is standardized and published

New module/repository structure is created

All components in scope are isolated with their own Terraform state

Module interfaces are documented and stable

CI/CD pipelines support independent deployments

Architecture and dependency diagrams are completed

Runbook, deployment, and rollback procedures are published

Final documentation is available in Confluence

7. Final Deliverables

Analysis Document

Refactoring Proposal

New Repository/Module Structure

Environment Variable Templates

Module Interface Documentation

Terraform State Management Strategy

Refactoring Runbook

Deployment Procedures

Rollback Procedures

Architecture Diagrams (As-Is & To-Be)

Updated Repository README / Onboarding Docs
