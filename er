1. Add a Null Resource for Pre-Check
Use a null_resource with a local-exec provisioner to execute an Azure CLI command (az vm list-skus) and check for available VM allocations in the desired zone.

resource "null_resource" "check_vm_allocation" {
  provisioner "local-exec" {
    command = <<EOT
      echo "Checking Azure capacity for VM size: ${var.vm_size} in region: ${var.location}..."
      result=$(az vm list-skus --location ${var.location} --query "[?name=='${var.vm_size}' && locationInfo[0].zones != null]" -o json)
      if [ -z "$result" ]; then
        echo "No capacity available for ${var.vm_size} in ${var.location}. Halting deployment."
        exit 1
      else
        echo "Capacity available for ${var.vm_size} in ${var.location}. Proceeding with deployment."
      fi
    EOT
  }
}


The Azure CLI command checks if the VM size exists in the requested region (var.location) and zones.
If no allocation is available, the script fails with exit 1, stopping Terraform from proceeding.
If capacity exists, the script proceeds.

2. Add Dependency on the Pre-Check
To ensure the VM creation only starts if the pre-check passes, make the VM module dependent on the null_resource.check_vm_allocation resource.

module "vm" {
  for_each             = toset([for i in range(1, var.vm_instances + 1) : tostring(i)])
  source               = "localterraform.com/AzurePMR/linux-vm/azurem"
  version              = "1.0.1"
  name                 = "${module.naming_convention.short_resource.azurerm_linux_virtual_machine}-${local.short_location}-${each.key}"
  resource_group_name  = var.resource_group_name
  location             = var.location
  size                 = var.vm_size
  source_image         = module.vm_image[each.key]
  admin_ssh_key_public_key = var.admin_ssh_key
  admin_ssh_username   = var.admin_ssh_username
  os_disk_name         = "${module.naming_convention.short_resource.azurerm_linux_virtual_machine}-dsk-${local.short_location}-${each.key}"
  managed_identity_ids = [data.azurerm_user_assigned_identity.app.id]
  disk_encryption_set_id = data.azurerm_disk_encryption_set.app.id
  network_interface_ids = [module.nic.network_interface_id]
  subnet_id            = module.subnet.id
  user_data            = base64encode("echo Custom Data Test")
  custom_data          = base64encode("echo Custom Data Test")
  data_disk_attachments = var.disable_data_disk_attachments.lun != null ? {
    lun = {
      managed_disk_id = module.data_disk[each.key].managed_disk_id
      caching         = var.data_disk_attachments_caching
    }
  } : {}
  tags                 = local.tags

  depends_on = [null_resource.check_vm_allocation] # Add dependency on the pre-check
}


4. Test the Implementation
Scenario 1: Capacity Available

When capacity exists in the requested region/zone, Terraform proceeds to deploy the VMs.
Scenario 2: Capacity Not Available

If capacity is unavailable, Terraform will halt with an error similar to:
javascript
Copiar cÃ³digo
Error: Command "az vm list-skus" exited with non-zero status: 1
No capacity available for Standard_D4s_v3 in eastus.

Benefits of This Approach
Proactive Check: Ensures deployment only starts when the requested VM size and zone have capacity.
Avoid Failures: Prevents Terraform from reaching a ZonalAllocationFailed error during deployment.
Scalability: This solution works seamlessly across multiple instances (for_each) and regions.
